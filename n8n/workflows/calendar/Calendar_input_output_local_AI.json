{
  "name": "Calendar_input/output",
  "nodes": [
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "19ad805e-f1cb-437c-a302-e8bd559a31a3",
              "name": "today",
              "value": "={{ $now.setZone('Europe/London').toISODate() }}",
              "type": "string"
            },
            {
              "id": "c5896503-0c84-481e-ba70-d04ac4e50322",
              "name": "nowStamp",
              "value": "={{ $now.setZone('Europe/London').toFormat('yyyyMMdd\\'T\\'HHmmss') }}",
              "type": "string"
            },
            {
              "id": "8b41e35f-7a7d-4b57-9cf8-9d05ba0fc2c8",
              "name": "request",
              "value": "={{ $json.body.text + \" [Current local time: \" + $now.setZone('Europe/London').toFormat('HH:mm') + \", Date: \" + $now.setZone('Europe/London').toISODate() + \"]\" }}",
              "type": "string"
            },
            {
              "id": "04b40b01-41df-4ef6-adcf-499510ed18aa",
              "name": "contactId",
              "value": "={{ $json.body.contactId }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -1344,
        192
      ],
      "id": "1aa971c8-c5bd-4783-9c18-d4cc449d1eab",
      "name": "Prepare_Calendar_Input"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "NBGxXNizyKNbxJ7a0k6sD",
          "mode": "list",
          "cachedResultUrl": "/workflow/NBGxXNizyKNbxJ7a0k6sD",
          "cachedResultName": "calendar_agent"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        0,
        0
      ],
      "id": "fc95cabc-a028-42bb-b182-1302baf88e3a",
      "name": "Execute_Calendar_Agent"
    },
    {
      "parameters": {
        "jsCode": "// Strip metadata from bridge FIRST, before any processing\nconst cleanedRequest = $json.request.toLowerCase().replace(/\\[current local time:.*?\\]/gi, '');\nconst request = cleanedRequest;\n\nlet action = 'add'; // default\n\n// Check for DELETE patterns first (before query, since \"cancel\" is more specific)\nconst deletePatterns = [\n  'cancel', 'delete', 'remove', 'drop', 'clear', 'wipe'\n];\n\nfor (const pattern of deletePatterns) {\n  if (request.includes(pattern)) {\n    action = 'delete';\n    break;\n  }\n}\n\n// Check if deleting ALL events (flexible patterns)\nlet deleteAll = false;\nif (action === 'delete') {\n  const allPatterns = [\n    /\\b(all|every|each)\\s*(my\\s*)?(events?|appointments?|meetings?|calendar)?\\b/i,\n    /\\b(everything)\\b/i,\n    /\\b(clear|wipe)\\s*(my\\s*)?(calendar|schedule|day)?\\b/i,\n    /\\b(the\\s*)?(whole|entire)\\s*(day|calendar|schedule)?\\b/i,\n    /\\b(delete|cancel|remove|drop)\\s+all\\b/i\n  ];\n  \n  for (const pattern of allPatterns) {\n    if (pattern.test(request)) {\n      deleteAll = true;\n      break;\n    }\n  }\n}\n\n// Check for QUERY patterns (only if not already delete)\nif (action !== 'delete') {\n  const queryPatterns = [\n    'what', 'show', 'list', 'schedule', 'calendar', 'busy', 'free', \n    'do i have', 'am i', 'check', 'summary', 'tell me',\n    'what\\'s on', 'whats on'\n  ];\n  for (const pattern of queryPatterns) {\n    if (request.includes(pattern)) {\n      action = 'query';\n      break;\n    }\n  }\n}\n\n// Parse date from request\nlet startDate = $json.today;\nlet endDate = $json.today;\n\nconst months = {\n  'jan': 0, 'january': 0,\n  'feb': 1, 'february': 1,\n  'mar': 2, 'march': 2,\n  'apr': 3, 'april': 3,\n  'may': 4,\n  'jun': 5, 'june': 5,\n  'jul': 6, 'july': 6,\n  'aug': 7, 'august': 7,\n  'sep': 8, 'september': 8,\n  'oct': 9, 'october': 9,\n  'nov': 10, 'november': 10,\n  'dec': 11, 'december': 11\n};\n\n// FIX #1: Check multi-word phrases BEFORE single words\n// Order matters! \"day after tomorrow\" must come before \"tomorrow\"\nif (request.includes('day before yesterday')) {\n  const dayBeforeYesterday = new Date($json.today);\n  dayBeforeYesterday.setDate(dayBeforeYesterday.getDate() - 2);\n  startDate = dayBeforeYesterday.toISOString().slice(0, 10);\n  endDate = startDate;\n} else if (request.includes('day after tomorrow')) {\n  const dayAfter = new Date($json.today);\n  dayAfter.setDate(dayAfter.getDate() + 2);\n  startDate = dayAfter.toISOString().slice(0, 10);\n  endDate = startDate;\n} else if (request.includes('tomorrow')) {\n  const tomorrow = new Date($json.today);\n  tomorrow.setDate(tomorrow.getDate() + 1);\n  startDate = tomorrow.toISOString().slice(0, 10);\n  endDate = startDate;\n} else if (request.includes('yesterday')) {\n  const yesterday = new Date($json.today);\n  yesterday.setDate(yesterday.getDate() - 1);\n  startDate = yesterday.toISOString().slice(0, 10);\n  endDate = startDate;\n} else if (/\\b(\\d+)\\s*days?\\s*ago\\b/i.test(request)) {\n  const daysAgoMatch = request.match(/\\b(\\d+)\\s*days?\\s*ago\\b/i);\n  const daysAgo = parseInt(daysAgoMatch[1]);\n  const pastDate = new Date($json.today);\n  pastDate.setDate(pastDate.getDate() - daysAgo);\n  startDate = pastDate.toISOString().slice(0, 10);\n  endDate = startDate;\n} else if (/\\bin\\s*(\\d+)\\s*days?\\b/i.test(request)) {\n  const inDaysMatch = request.match(/\\bin\\s*(\\d+)\\s*days?\\b/i);\n  const inDays = parseInt(inDaysMatch[1]);\n  const futureDate = new Date($json.today);\n  futureDate.setDate(futureDate.getDate() + inDays);\n  startDate = futureDate.toISOString().slice(0, 10);\n  endDate = startDate;\n// FIX #3: Match \"the week\", \"this week\", or just \"week\" for weekly queries\n} else if (/\\b(this\\s+week|the\\s+week|for\\s+the\\s+week)\\b/i.test(request)) {\n  const today = new Date($json.today);\n  const dayOfWeek = today.getDay(); // 0 = Sunday, 1 = Monday, etc.\n  \n  // Start from Monday of current week\n  const startOfWeek = new Date(today);\n  const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1; // Adjust for Monday start\n  startOfWeek.setDate(today.getDate() - daysFromMonday);\n  \n  // End on Sunday\n  const endOfWeek = new Date(startOfWeek);\n  endOfWeek.setDate(startOfWeek.getDate() + 6);\n  \n  startDate = startOfWeek.toISOString().slice(0, 10);\n  endDate = endOfWeek.toISOString().slice(0, 10);\n} else if (request.includes('next week')) {\n  const today = new Date($json.today);\n  const dayOfWeek = today.getDay();\n  const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;\n  \n  // Start from next Monday\n  const startOfNextWeek = new Date(today);\n  startOfNextWeek.setDate(today.getDate() - daysFromMonday + 7);\n  \n  const endOfNextWeek = new Date(startOfNextWeek);\n  endOfNextWeek.setDate(startOfNextWeek.getDate() + 6);\n  \n  startDate = startOfNextWeek.toISOString().slice(0, 10);\n  endDate = endOfNextWeek.toISOString().slice(0, 10);\n} else if (/\\blast\\s+week\\b/i.test(request)) {\n  const today = new Date($json.today);\n  const dayOfWeek = today.getDay();\n  const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;\n  \n  // Start from last Monday (7 days before this Monday)\n  const startOfLastWeek = new Date(today);\n  startOfLastWeek.setDate(today.getDate() - daysFromMonday - 7);\n  \n  // End on last Sunday\n  const endOfLastWeek = new Date(startOfLastWeek);\n  endOfLastWeek.setDate(startOfLastWeek.getDate() + 6);\n  \n  startDate = startOfLastWeek.toISOString().slice(0, 10);\n  endDate = endOfLastWeek.toISOString().slice(0, 10);\n\n// Day name mapping (includes all abbreviations)\n// Defined here so it's available for both patterns below\n} else if (/\\b(next|this|last)\\s+(mon|monday|tue|tues|tuesday|wed|wednesday|thu|thur|thurs|thursday|fri|friday|sat|saturday|sun|sunday)\\b/i.test(request)) {\n  // Day names with modifiers: \"next Monday\", \"this Fri\", \"last Tues\"\n  const dayNameToNum = {\n    'sun': 0, 'sunday': 0,\n    'mon': 1, 'monday': 1,\n    'tue': 2, 'tues': 2, 'tuesday': 2,\n    'wed': 3, 'wednesday': 3,\n    'thu': 4, 'thur': 4, 'thurs': 4, 'thursday': 4,\n    'fri': 5, 'friday': 5,\n    'sat': 6, 'saturday': 6\n  };\n  \n  const match = request.match(/\\b(next|this|last)\\s+(mon|monday|tue|tues|tuesday|wed|wednesday|thu|thur|thurs|thursday|fri|friday|sat|saturday|sun|sunday)\\b/i);\n  const modifier = match[1].toLowerCase();\n  const targetDayName = match[2].toLowerCase();\n  const targetDayNum = dayNameToNum[targetDayName];\n  \n  const today = new Date($json.today);\n  const currentDayNum = today.getDay();\n  \n  let daysToAdd = targetDayNum - currentDayNum;\n  \n  if (modifier === 'next') {\n    // Next = the coming occurrence in the next 7 days, or +7 if same day\n    if (daysToAdd <= 0) daysToAdd += 7;\n  } else if (modifier === 'last') {\n    // Last = the previous occurrence\n    if (daysToAdd >= 0) daysToAdd -= 7;\n  } else if (modifier === 'this') {\n    // This = this week's occurrence (could be past or future within the week)\n    // If day already passed this week, still use it (for queries like \"what was on this Monday\")\n  }\n  \n  const targetDate = new Date(today);\n  targetDate.setDate(today.getDate() + daysToAdd);\n  startDate = targetDate.toISOString().slice(0, 10);\n  endDate = startDate;\n\n// Bare day names: \"Monday\", \"on Fri\", \"Tues schedule\"\n} else if (/\\b(mon|monday|tue|tues|tuesday|wed|wednesday|thu|thur|thurs|thursday|fri|friday|sat|saturday|sun|sunday)\\b/i.test(request)) {\n  const dayNameToNum = {\n    'sun': 0, 'sunday': 0,\n    'mon': 1, 'monday': 1,\n    'tue': 2, 'tues': 2, 'tuesday': 2,\n    'wed': 3, 'wednesday': 3,\n    'thu': 4, 'thur': 4, 'thurs': 4, 'thursday': 4,\n    'fri': 5, 'friday': 5,\n    'sat': 6, 'saturday': 6\n  };\n  \n  const match = request.match(/\\b(mon|monday|tue|tues|tuesday|wed|wednesday|thu|thur|thurs|thursday|fri|friday|sat|saturday|sun|sunday)\\b/i);\n  const targetDayName = match[1].toLowerCase();\n  const targetDayNum = dayNameToNum[targetDayName];\n  \n  const today = new Date($json.today);\n  const currentDayNum = today.getDay();\n  \n  // Default behavior: find the NEXT occurrence (including today if it matches)\n  let daysToAdd = targetDayNum - currentDayNum;\n  if (daysToAdd < 0) daysToAdd += 7; // If day passed this week, go to next week\n  \n  const targetDate = new Date(today);\n  targetDate.setDate(today.getDate() + daysToAdd);\n  startDate = targetDate.toISOString().slice(0, 10);\n  endDate = startDate;\n\n// Month patterns: \"this month\", \"the month\", \"next month\"\n} else if (/\\b(this\\s+month|the\\s+month|for\\s+the\\s+month)\\b/i.test(request)) {\n  const today = new Date($json.today);\n  \n  // Start from 1st of current month\n  const startOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);\n  \n  // End on last day of current month\n  const endOfMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0);\n  \n  startDate = startOfMonth.toISOString().slice(0, 10);\n  endDate = endOfMonth.toISOString().slice(0, 10);\n} else if (/\\bnext\\s+month\\b/i.test(request)) {\n  const today = new Date($json.today);\n  \n  // Start from 1st of next month\n  const startOfNextMonth = new Date(today.getFullYear(), today.getMonth() + 1, 1);\n  \n  // End on last day of next month\n  const endOfNextMonth = new Date(today.getFullYear(), today.getMonth() + 2, 0);\n  \n  startDate = startOfNextMonth.toISOString().slice(0, 10);\n  endDate = endOfNextMonth.toISOString().slice(0, 10);\n} else if (/\\blast\\s+month\\b/i.test(request)) {\n  const today = new Date($json.today);\n  \n  // Start from 1st of last month\n  const startOfLastMonth = new Date(today.getFullYear(), today.getMonth() - 1, 1);\n  \n  // End on last day of last month\n  const endOfLastMonth = new Date(today.getFullYear(), today.getMonth(), 0);\n  \n  startDate = startOfLastMonth.toISOString().slice(0, 10);\n  endDate = endOfLastMonth.toISOString().slice(0, 10);\n} else {\n  // Try to parse specific dates\n  let dateParsed = false;\n  \n  // Pattern 1: Date WITH month - \"9th jan\", \"jan 9\", \"january 15\", \"15th january\"\n  const dateWithMonthPattern = /(\\d{1,2})(?:st|nd|rd|th)?\\s*(jan|january|feb|february|mar|march|apr|april|may|jun|june|jul|july|aug|august|sep|september|oct|october|nov|november|dec|december)|(jan|january|feb|february|mar|march|apr|april|may|jun|june|jul|july|aug|august|sep|september|oct|october|nov|november|dec|december)\\s*(\\d{1,2})(?:st|nd|rd|th)?/i;\n  \n  const matchWithMonth = request.match(dateWithMonthPattern);\n  if (matchWithMonth) {\n    let day, monthStr;\n    if (matchWithMonth[1] && matchWithMonth[2]) {\n      day = parseInt(matchWithMonth[1]);\n      monthStr = matchWithMonth[2].toLowerCase();\n    } else if (matchWithMonth[3] && matchWithMonth[4]) {\n      monthStr = matchWithMonth[3].toLowerCase();\n      day = parseInt(matchWithMonth[4]);\n    }\n    \n    if (day && monthStr && months.hasOwnProperty(monthStr)) {\n      const year = new Date($json.today).getFullYear();\n      const parsedDate = new Date(year, months[monthStr], day);\n      startDate = parsedDate.toISOString().slice(0, 10);\n      endDate = startDate;\n      dateParsed = true;\n    }\n  }\n  \n  // FIX #2: Pattern 2: Bare ordinal WITHOUT month - \"the 22nd\", \"on the 5th\", \"22nd\"\n  // Assumes current month (or next month if date has passed)\n  if (!dateParsed) {\n    const bareOrdinalPattern = /\\b(?:the\\s+)?(\\d{1,2})(?:st|nd|rd|th)\\b/i;\n    const matchBare = request.match(bareOrdinalPattern);\n    \n    if (matchBare) {\n      const day = parseInt(matchBare[1]);\n      const today = new Date($json.today);\n      const currentMonth = today.getMonth();\n      const currentYear = today.getFullYear();\n      const currentDay = today.getDate();\n      \n      // Validate day is reasonable (1-31)\n      if (day >= 1 && day <= 31) {\n        let targetMonth = currentMonth;\n        let targetYear = currentYear;\n        \n        // If the day has already passed this month, assume next month\n        if (day < currentDay) {\n          targetMonth = currentMonth + 1;\n          if (targetMonth > 11) {\n            targetMonth = 0;\n            targetYear++;\n          }\n        }\n        \n        const parsedDate = new Date(targetYear, targetMonth, day);\n        // Verify the date is valid (handles cases like \"31st\" in a 30-day month)\n        if (parsedDate.getDate() === day) {\n          startDate = parsedDate.toISOString().slice(0, 10);\n          endDate = startDate;\n          dateParsed = true;\n        }\n      }\n    }\n  }\n}\n\n// Extract search term for delete (the event title/description)\nlet searchTerm = '';\nif (action === 'delete' && !deleteAll) {\n  searchTerm = request\n    .replace(/\\b(cancel|delete|remove|drop|clear|wipe)\\b/gi, '')\n    .replace(/\\b(my|the|a|an)\\b/gi, '')\n    .replace(/\\b(tomorrow|today|tonight|yesterday)\\b/gi, '')\n    .replace(/\\b(day before yesterday|day after tomorrow)\\b/gi, '')\n    .replace(/\\b\\d+\\s*days?\\s*ago\\b/gi, '')\n    .replace(/\\bin\\s*\\d+\\s*days?\\b/gi, '')\n    .replace(/\\b(on|at|for)\\b/gi, '')\n    .replace(/\\b(\\d{1,2})(st|nd|rd|th)?\\s*(jan|january|feb|february|mar|march|apr|april|may|jun|june|jul|july|aug|august|sep|september|oct|october|nov|november|dec|december)\\b/gi, '')\n    .replace(/\\b(jan|january|feb|february|mar|march|apr|april|may|jun|june|jul|july|aug|august|sep|september|oct|october|nov|november|dec|december)\\s*(\\d{1,2})(st|nd|rd|th)?\\b/gi, '')\n    .replace(/\\b\\d{1,2}(:\\d{2})?\\s*(am|pm)?\\b/gi, '')\n    .replace(/\\s+/g, ' ')\n    .trim();\n}\n\n// Extract time for more precise matching (only if user explicitly specified a time)\nlet searchTime = '';\nconst timeMatch = request.match(/\\b(\\d{1,2})(?::(\\d{2}))?\\s*(am|pm)\\b/i);\nif (timeMatch) {\n  let hour = parseInt(timeMatch[1]);\n  const minutes = timeMatch[2] || '00';\n  const ampm = timeMatch[3]?.toLowerCase();\n  \n  if (ampm === 'pm' && hour !== 12) hour += 12;\n  if (ampm === 'am' && hour === 12) hour = 0;\n  \n  searchTime = `${hour.toString().padStart(2, '0')}:${minutes}`;\n}\n\nreturn {\n  json: {\n    ...$json,\n    action: action,\n    startDate: startDate,\n    endDate: endDate,\n    searchTerm: searchTerm,\n    searchTime: searchTime,\n    deleteAll: deleteAll\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1120,
        192
      ],
      "id": "ccb70d13-45b0-42fd-834f-c690af59fd13",
      "name": "Classify_Request"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.action }}",
                    "rightValue": "add",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "bffa7e40-e9cb-4684-833f-d6b37dd81dc8"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "add"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "6357fc41-41db-4dff-b466-305af228e00b",
                    "leftValue": "={{ $json.action }}",
                    "rightValue": "query",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "query"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "1a658956-8443-4659-a35b-7b5e444bedd6",
                    "leftValue": "={{ $json.action }}",
                    "rightValue": "delete",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "delete"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.4,
      "position": [
        -896,
        176
      ],
      "id": "e20eaaf2-c710-49a8-9736-9264c0acd633",
      "name": "Route_Action"
    },
    {
      "parameters": {
        "jsCode": "const response = $json.data || $json.body || '';\nconst contactId = $('Classify_Request').item.json.contactId;\nconst startDate = $('Classify_Request').item.json.startDate;\nconst endDate = $('Classify_Request').item.json.endDate;\n\n// Extract VEVENT blocks from the CalDAV response\nconst vevents = response.match(/BEGIN:VEVENT[\\s\\S]*?END:VEVENT/g) || [];\n\nif (vevents.length === 0) {\n  // Show date range if multi-day query\n  const dateDisplay = (startDate !== endDate) \n    ? `${startDate} to ${endDate}` \n    : startDate;\n  return {\n    json: {\n      contactId: contactId,\n      message: `üìÖ No events found for ${dateDisplay}`\n    }\n  };\n}\n\n// Parse each event\nconst events = vevents.map(vevent => {\n  const summary = vevent.match(/SUMMARY:(.+)/)?.[1]?.trim() || 'Untitled';\n  const dtstart = vevent.match(/DTSTART[^:]*:(\\d{8}T\\d{6})/)?.[1] || '';\n  const dtend = vevent.match(/DTEND[^:]*:(\\d{8}T\\d{6})/)?.[1] || '';\n  \n  // Extract date (YYYY-MM-DD format)\n  let eventDate = '';\n  if (dtstart) {\n    eventDate = dtstart.slice(0, 4) + '-' + dtstart.slice(4, 6) + '-' + dtstart.slice(6, 8);\n  }\n  \n  // Format time\n  let startTime = '';\n  if (dtstart) {\n    startTime = dtstart.slice(9, 11) + ':' + dtstart.slice(11, 13);\n  }\n  let endTime = '';\n  if (dtend) {\n    endTime = dtend.slice(9, 11) + ':' + dtend.slice(11, 13);\n  }\n  \n  return { summary, eventDate, startTime, endTime };\n});\n\n// Sort by date then time\nevents.sort((a, b) => {\n  const dateCompare = a.eventDate.localeCompare(b.eventDate);\n  if (dateCompare !== 0) return dateCompare;\n  return a.startTime.localeCompare(b.startTime);\n});\n\n// Check if this is a multi-day query\nconst isMultiDay = startDate !== endDate;\n\nlet message = '';\n\nif (isMultiDay) {\n  // Group events by date for multi-day queries\n  const eventsByDate = {};\n  events.forEach(e => {\n    if (!eventsByDate[e.eventDate]) {\n      eventsByDate[e.eventDate] = [];\n    }\n    eventsByDate[e.eventDate].push(e);\n  });\n  \n  message = `üìÖ Schedule for ${startDate} to ${endDate}:\\n`;\n  \n  // Get sorted dates\n  const dates = Object.keys(eventsByDate).sort();\n  \n  dates.forEach(date => {\n    // Format date as day name (Mon, Tue, etc)\n    const dateObj = new Date(date + 'T12:00:00');\n    const dayName = dateObj.toLocaleDateString('en-GB', { weekday: 'short', day: 'numeric', month: 'short' });\n    \n    message += `\\n**${dayName}**\\n`;\n    eventsByDate[date].forEach(e => {\n      message += `‚Ä¢ ${e.startTime}-${e.endTime}: ${e.summary}\\n`;\n    });\n  });\n} else {\n  // Single day - original format\n  message = `üìÖ Schedule for ${startDate}:\\n\\n`;\n  events.forEach(e => {\n    message += `‚Ä¢ ${e.startTime}-${e.endTime}: ${e.summary}\\n`;\n  });\n}\n\nreturn {\n  json: {\n    contactId: contactId,\n    message: message\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        192
      ],
      "id": "6e6c6d87-12bd-4db6-aae4-21fef9d83848",
      "name": "Format_Calendar_Response"
    },
    {
      "parameters": {
        "jsCode": "const searchDate = $json.startDate;\nconst searchTerm = $json.searchTerm || '';\nconst searchTime = $json.searchTime || '';\n\n// Use environment variables - no hardcoded credentials\nconst calendarUrl = $env.NEXTCLOUD_URL;\nconst username = $env.NEXTCLOUD_USERNAME;\nconst password = $env.NEXTCLOUD_PASSWORD;\n\n// Format date for CalDAV query\nconst formattedDate = searchDate.replace(/-/g, '');\n\nconst body = `<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<C:calendar-query xmlns:D=\"DAV:\" xmlns:C=\"urn:ietf:params:xml:ns:caldav\">\n  <D:prop>\n    <D:getetag/>\n    <C:calendar-data/>\n  </D:prop>\n  <C:filter>\n    <C:comp-filter name=\"VCALENDAR\">\n      <C:comp-filter name=\"VEVENT\">\n        <C:time-range start=\"${formattedDate}T000000Z\" end=\"${formattedDate}T235959Z\"/>\n      </C:comp-filter>\n    </C:comp-filter>\n  </C:filter>\n</C:calendar-query>`;\n\nlet response;\ntry {\n  response = await this.helpers.httpRequest({\n    method: 'REPORT',\n    url: calendarUrl,\n    headers: {\n      'Content-Type': 'application/xml; charset=utf-8',\n      'Depth': '1',\n      'Authorization': 'Basic ' + Buffer.from(username + ':' + password).toString('base64')\n    },\n    body: body,\n    returnFullResponse: true\n  });\n} catch (error) {\n  return {\n    json: {\n      ...$json,\n      matches: [],\n      matchCount: 0,\n      error: `Calendar query failed: ${error.message}`\n    }\n  };\n}\n\n// Parse the XML response to extract events\nconst events = [];\nconst responseBody = response.body || response;\n\nconst hrefRegex = /<d:href>([^<]+)<\\/d:href>/gi;\nconst calDataRegex = /<cal:calendar-data[^>]*>([\\s\\S]*?)<\\/cal:calendar-data>/gi;\n\nlet hrefMatches = [...responseBody.matchAll(hrefRegex)];\nlet calDataMatches = [...responseBody.matchAll(calDataRegex)];\n\nfor (let i = 0; i < calDataMatches.length; i++) {\n  const icsData = calDataMatches[i][1];\n  const href = hrefMatches[i]?.[1] || '';\n  \n  // Extract SUMMARY\n  const summaryMatch = icsData.match(/SUMMARY:(.+?)(?:\\r?\\n|$)/);\n  const summary = summaryMatch ? summaryMatch[1].trim() : 'Untitled';\n  \n  // Extract DTSTART\n  const dtstartMatch = icsData.match(/DTSTART[^:]*:(\\d{4})(\\d{2})(\\d{2})T?(\\d{2})?(\\d{2})?/);\n  let startTime = '';\n  let displayTime = '';\n  if (dtstartMatch) {\n    if (dtstartMatch[4] && dtstartMatch[5]) {\n      startTime = `${dtstartMatch[4]}:${dtstartMatch[5]}`;\n      let hour = parseInt(dtstartMatch[4]);\n      const ampm = hour >= 12 ? 'PM' : 'AM';\n      hour = hour % 12 || 12;\n      displayTime = `${hour}:${dtstartMatch[5]} ${ampm}`;\n    } else {\n      displayTime = 'All day';\n    }\n  }\n  \n  // Extract UID\n  const uidMatch = icsData.match(/UID:(.+?)(?:\\r?\\n|$)/);\n  const uid = uidMatch ? uidMatch[1].trim() : '';\n  \n  events.push({\n    summary,\n    startTime,\n    displayTime,\n    href,\n    uid,\n    icsData\n  });\n}\n\n// Filter matches based on search criteria\nlet matches = events.filter(event => {\n  const summaryLower = event.summary.toLowerCase();\n  const searchLower = searchTerm.toLowerCase();\n  \n  // Bidirectional matching: \n  // - searchTerm in summary (\"test\" matches \"Test Event\")\n  // - summary in searchTerm (\"Test\" matches \"delete test event\")\n  const termMatch = !searchTerm || \n    summaryLower.includes(searchLower) ||\n    searchLower.includes(summaryLower);\n  \n  const timeMatch = !searchTime || \n    event.startTime === searchTime;\n  \n  if (searchTerm && searchTime) {\n    return termMatch && timeMatch;\n  }\n  \n  return termMatch || (searchTime && timeMatch);\n});\n\nif (!searchTerm && !searchTime) {\n  matches = events;\n}\n\nreturn {\n  json: {\n    ...$json,\n    matches: matches,\n    matchCount: matches.length,\n    allEventsOnDay: events.length\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -672,
        672
      ],
      "id": "5339ac0c-eab6-491e-9cea-40c954b02996",
      "name": "Find_Matching_Events"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "b13a01f4-c571-4783-afb8-eff80a4ae6a8",
                    "leftValue": "={{ $json.deleteAll }}",
                    "rightValue": "true",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "delete all"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.matchCount }}",
                    "rightValue": 0,
                    "operator": {
                      "type": "number",
                      "operation": "equals"
                    },
                    "id": "116d6601-5d34-4f92-b1db-94152c4340b1"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "no match"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "b6959d93-5c5c-477d-aa4e-b4649b4df227",
                    "leftValue": "={{ $json.matchCount }}",
                    "rightValue": 1,
                    "operator": {
                      "type": "number",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "single match"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "49fed86d-ca8b-408a-a40b-6ebea5701659",
                    "leftValue": "={{ $json.matchCount }}",
                    "rightValue": 1,
                    "operator": {
                      "type": "number",
                      "operation": "gt"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "multiple matches"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.4,
      "position": [
        -448,
        640
      ],
      "id": "ed8cb1ed-c14c-4361-bb4d-58f627d632cf",
      "name": "Handle_Delete_Logic"
    },
    {
      "parameters": {
        "jsCode": "const searchTerm = $json.searchTerm || 'that event';\nconst searchDate = $json.startDate;\n\n// Format date nicely\nconst dateObj = new Date(searchDate + 'T12:00:00');\nconst options = { weekday: 'long', month: 'long', day: 'numeric' };\nconst formattedDate = dateObj.toLocaleDateString('en-US', options);\n\nlet message = `‚ùå No matching events found for \"${searchTerm}\" on ${formattedDate}.`;\n\nif ($json.allEventsOnDay > 0) {\n  message += `\\n\\nYou have ${$json.allEventsOnDay} event(s) that day. Try being more specific with the event name or time.`;\n}\n\nreturn {\n  json: {\n    reply: message\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        576
      ],
      "id": "34de6261-3d73-4922-91ff-47f23df0f5d0",
      "name": "No_Matches_Reply"
    },
    {
      "parameters": {
        "method": "DELETE",
        "url": "=http://nextcloud{{ $json.matches[0].href }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        -176,
        704
      ],
      "id": "63b088b9-9498-4d63-9a08-c242694d270f",
      "name": "Execute_Delete",
      "credentials": {
        "httpBasicAuth": {
          "id": "3J7PuDtrV5vizZsi",
          "name": "Unnamed credential"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const deleted = $('Find_Matching_Events').first().json.matches[0];\nconst searchDate = $('Find_Matching_Events').first().json.startDate;\n\nconst message = `‚úÖ Deleted: ${deleted.summary} (${deleted.displayTime}, ${searchDate})`;\n\nreturn {\n  json: {\n    reply: message\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        768
      ],
      "id": "2d9b2b08-1a99-45e3-a9d0-4078b3b3eb26",
      "name": "Delete_Success_Reply"
    },
    {
      "parameters": {
        "jsCode": "const matches = $json.matches;\nconst searchDate = $json.startDate;\n\n// Format date nicely  \nconst dateObj = new Date(searchDate + 'T12:00:00');\nconst options = { weekday: 'long', month: 'long', day: 'numeric' };\nconst formattedDate = dateObj.toLocaleDateString('en-US', options);\n\nlet message = `ü§î Found ${matches.length} events on ${formattedDate}:\\n\\n`;\n\nmatches.forEach((event, index) => {\n  message += `${index + 1}. ${event.summary} (${event.displayTime})\\n`;\n});\n\nmessage += `\\nPlease be more specific - include the event name or time, e.g., \"cancel the 3pm meeting\"`;\n\nreturn {\n  json: {\n    reply: message\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        960
      ],
      "id": "aa1ebd37-99d9-4c79-ab12-ea053e9c899d",
      "name": "Multiple_Matches_Reply"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Execute_Bulk_Delete - Calendar Event Deletion\n * \n * Workflow: Calendar_input/output\n * Node: Create_Execute_Bulk_Delete\n * \n * Purpose: Deletes one or more calendar events via CalDAV DELETE requests.\n *          Used for both single event deletion and bulk \"clear all\" operations.\n * \n * Environment Variables Required:\n *   - NEXTCLOUD_USERNAME: Nextcloud username\n *   - NEXTCLOUD_PASSWORD: Nextcloud app password\n * \n * Input: $json.matches (array of events with href property)\n * Output: results[], successCount, failCount\n * \n * Last updated: 2026-01-25\n */\n\nconst matches = $json.matches;\nconst username = $env.NEXTCLOUD_USERNAME;\nconst password = $env.NEXTCLOUD_PASSWORD;\n\nconst results = [];\n\nfor (const event of matches) {\n  try {\n    await this.helpers.httpRequest({\n      method: 'DELETE',\n      url: `http://nextcloud${event.href}`,\n      headers: {\n        'Authorization': 'Basic ' + Buffer.from(username + ':' + password).toString('base64')\n      }\n    });\n    results.push({ success: true, summary: event.summary });\n  } catch (error) {\n    results.push({ success: false, summary: event.summary, error: error.message });\n  }\n}\n\nconst successCount = results.filter(r => r.success).length;\nconst failCount = results.filter(r => !r.success).length;\n\nreturn {\n  json: {\n    ...$json,\n    results: results,\n    successCount: successCount,\n    failCount: failCount\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -224,
        384
      ],
      "id": "81ec2f25-5cf5-423f-8697-d0debe71573a",
      "name": "Create Execute_Bulk_Delete"
    },
    {
      "parameters": {
        "jsCode": "const successCount = $json.successCount;\nconst failCount = $json.failCount;\nconst searchDate = $json.startDate;\n\n// Format date nicely\nconst dateObj = new Date(searchDate + 'T12:00:00');\nconst options = { weekday: 'long', month: 'long', day: 'numeric' };\nconst formattedDate = dateObj.toLocaleDateString('en-US', options);\n\nlet message = `‚úÖ Deleted ${successCount} event(s) from ${formattedDate}`;\n\nif (failCount > 0) {\n  message += `\\n‚ö†Ô∏è Failed to delete ${failCount} event(s)`;\n}\n\nreturn {\n  json: {\n    reply: message\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        384
      ],
      "id": "19129f1b-8f55-43c2-90eb-781cd4e60c90",
      "name": "Create Bulk_Delete_Success_Reply"
    },
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -1568,
        192
      ],
      "id": "b503485f-061d-4248-a7f4-f7d295fa7a66",
      "name": "When Executed by Another Workflow"
    },
    {
      "parameters": {
        "contactId": "={{ $json.contactId || $('Classify_Request').item.json.contactId }}",
        "message": "={{ $json.reply || $json.message || \"‚úÖ Event added: \" + $('Classify_Request').item.json.request }}"
      },
      "type": "n8n-nodes-simplexity.simplexity",
      "typeVersion": 1,
      "position": [
        432,
        464
      ],
      "id": "a8b2ec86-fe3e-4afe-8990-329c37696298",
      "name": "Reply_SimpleX",
      "credentials": {
        "simplexityApi": {
          "id": "wWS1DFmUG7TUV8Sk",
          "name": "SimpleXity Config account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const calendarUrl = $env.NEXTCLOUD_URL;\nconst username = $env.NEXTCLOUD_USERNAME;\nconst password = $env.NEXTCLOUD_PASSWORD;\n\nconst startDate = $json.startDate.replace(/-/g, '');\nconst endDate = $json.endDate.replace(/-/g, '');\n\nconst body = `<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<C:calendar-query xmlns:D=\"DAV:\" xmlns:C=\"urn:ietf:params:xml:ns:caldav\">\n  <D:prop>\n    <D:getetag/>\n    <C:calendar-data/>\n  </D:prop>\n  <C:filter>\n    <C:comp-filter name=\"VCALENDAR\">\n      <C:comp-filter name=\"VEVENT\">\n        <C:time-range start=\"${startDate}T000000Z\" end=\"${endDate}T235959Z\"/>\n      </C:comp-filter>\n    </C:comp-filter>\n  </C:filter>\n</C:calendar-query>`;\n\nconst response = await this.helpers.httpRequest({\n  method: 'REPORT',\n  url: calendarUrl,\n  headers: {\n    'Content-Type': 'application/xml; charset=utf-8',\n    'Depth': '1',\n    'Authorization': 'Basic ' + Buffer.from(username + ':' + password).toString('base64')\n  },\n  body: body,\n  returnFullResponse: true\n});\n\nreturn {\n  json: {\n    data: response.body,\n    statusCode: response.statusCode,\n    contactId: $json.contactId,\n    startDate: $json.startDate,\n    endDate: $json.endDate\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -224,
        192
      ],
      "id": "c12bec8c-ac5c-4f57-8393-f27c95121f60",
      "name": "Query_Calendar"
    }
  ],
  "pinData": {},
  "connections": {
    "Prepare_Calendar_Input": {
      "main": [
        [
          {
            "node": "Classify_Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Classify_Request": {
      "main": [
        [
          {
            "node": "Route_Action",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route_Action": {
      "main": [
        [
          {
            "node": "Execute_Calendar_Agent",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Query_Calendar",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Find_Matching_Events",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Find_Matching_Events": {
      "main": [
        [
          {
            "node": "Handle_Delete_Logic",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Handle_Delete_Logic": {
      "main": [
        [
          {
            "node": "Create Execute_Bulk_Delete",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No_Matches_Reply",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Execute_Delete",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Multiple_Matches_Reply",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute_Delete": {
      "main": [
        [
          {
            "node": "Delete_Success_Reply",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Execute_Bulk_Delete": {
      "main": [
        [
          {
            "node": "Create Bulk_Delete_Success_Reply",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When Executed by Another Workflow": {
      "main": [
        [
          {
            "node": "Prepare_Calendar_Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute_Calendar_Agent": {
      "main": [
        [
          {
            "node": "Reply_SimpleX",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format_Calendar_Response": {
      "main": [
        [
          {
            "node": "Reply_SimpleX",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Bulk_Delete_Success_Reply": {
      "main": [
        [
          {
            "node": "Reply_SimpleX",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No_Matches_Reply": {
      "main": [
        [
          {
            "node": "Reply_SimpleX",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete_Success_Reply": {
      "main": [
        [
          {
            "node": "Reply_SimpleX",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Multiple_Matches_Reply": {
      "main": [
        [
          {
            "node": "Reply_SimpleX",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Query_Calendar": {
      "main": [
        [
          {
            "node": "Format_Calendar_Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "availableInMCP": false
  },
  "versionId": "e7e5a6e4-b637-412b-b662-0e92e37c0fc5",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "a5af9c56908a68ed8b8b4eedf2ab29753e321c82b755d88674ae79dcfc198c21"
  },
  "id": "Zu7jopYH4OObgvwEzM6aG",
  "tags": []
}